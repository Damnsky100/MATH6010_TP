---
title: "Regression Lasso"
output: html_notebook
---

## Install library  
```{r}
#install.packages("lubridate")
library(lubridate)
library(PerformanceAnalytics)
library(here)
library(xts)
library(zoo)
library(TTR)
library(stats)
library(caret)
library(glmnet)
library(Metrics)
library(quantmod)

source(here("Function", "f_clean_data.R"))
source(here("Function", "f_cluster_DOW.R"))

rolling_window <- function(data, window_size) {
  # Number of windows
  n_windows <- length(data) - window_size + 1
  
  # Initialize matrix to store rolling windows
  result <- matrix(NA, nrow = window_size, ncol = n_windows)
  
  
  # Populate matrices with rolling windows and dates
  for (i in 1:n_windows) {
    result[, i] <- data[i:(i + window_size - 1)]
  }
    result
}


f_cumulativeReturnRolling <- function(data, window_size){
    n_windows <- nrow(data) - window_size + 1
    tmp <- rolling_window(as.numeric(data$return), window_size)
    cumulative_returns <- apply(tmp, 2, PerformanceAnalytics::Return.cumulative)
    dates = index(data)
    df = data.frame(cumulative_returns)
    rownames(df) = dates[1:n_windows]
    df
}




```


## Download data price of our 30 stocks from 2000 to 2023
```{r}

df_price <- read.csv(here("Raw_Data", "data_price2.csv")) 
df_price <- subset(df_price, select = -c(cusip)) # Get rid of the column name cusip
df_price$date <- as.Date(df_price$date, format="%Y-%m-%d")

df_price <- xts(df_price[, -which(names(df_price) == "date")], order.by=df_price$date)

df_price[is.na(df_price)] <- 0 # A few returns that gives NA, we put them at 0





```


## Start Building Features for the linear regression

```{r}

f_constructFeatures <- function(ticker, df_price, window_size){
    # A few technical indicators functions from TTR, see class notes 
    # for their definition
    f_ATR <- function(x)
        ATR(HLC(x))[, 'atr']
    f_ADX <- function(x)
        ADX(HLC(x))[, 'ADX']
    f_Aroon <- function(x)
        aroon(cbind(Hi(x), Lo(x)), n = 2)$oscillator
    f_BB <- function(x)
        BBands(HLC(x))[, "pctB"]
    f_ChaikinVol <- function(x)
        Delt(chaikinVolatility(cbind(Hi(x), Lo(x))))[, 1]
    f_CLV <- function(x)
        EMA(CLV(HLC(x)))[, 1]
    f_EMV <- function(x)
        EMV(cbind(Hi(x), Lo(x)), Vo(x))[, 2]
    f_MACD <- function(x)
        MACD(Cl(x))[, 2]
    f_MFI <- function(x)
        MFI(HLC(x), Vo(x))
    f_SAR <- function(x)
        SAR(cbind(Hi(x), Cl(x))) [, 1]
    f_SMI <- function(x)
        SMI(HLC(x))[, "SMI"]
    f_Volat <- function(x)
        volatility(OHLC(x), calc = "garman")[, 1]


    #Select the right tickers
    data <- df_price[df_price$ticker %in% tickers, ]

    # Create a base name from ticker by removing any character that is not
    # a number or letter and then converting the results to lower case letters
    base_name <- tolower(gsub("[[:punct:]]", "", ticker))
  
   #Select the right tickers
    data <- df_price[df_price$ticker %in% ticker, ]

    tmp <- subset(data, select = -c(secid, ticker))
    dates <- as.Date(index(tmp))
    numeric_tmp <- as.data.frame(lapply(tmp, as.numeric))
    data_xts <- xts::as.xts(numeric_tmp, order.by=dates)


    ## Retrouver 10 jours forecast returns
    retLead <- f_cumulativeReturnRolling(data, window_size)
    retLead = as.xts(retLead)
    index(retLead) = as.Date(index(retLead))
    ret_closeLead <- stats::lag(retLead, k=-1)

    data_xtsInput <- data_xts[index(data_xts) %in% index(retLead), ]

    ret = as.xts(data_xtsInput$ret)
  
# Create data.frame with output variable and predictors
df_ticker <- data.frame(
    date = index(data_xtsInput),
    retLead = ret_closeLead,
    coredata(stats::lag(ret, k = 0:3)),
    atr = coredata(f_ATR(data_xtsInput)),
    adx = coredata(f_ADX(data_xtsInput)),
    aroon = coredata(f_Aroon(data_xtsInput)),
    bb = coredata(f_BB(data_xtsInput)),
    chaikin_vol = coredata(f_ChaikinVol(data_xtsInput)),
    clv = coredata(f_CLV(data_xtsInput)),
    emv = coredata(f_EMV(data_xtsInput)),
    macd = coredata(f_MACD(data_xtsInput)),
    mfi = coredata(f_MFI(data_xtsInput)),
    sar = coredata(f_SAR(data_xtsInput)),
    smi = coredata(f_SMI(data_xtsInput)),
    volat = coredata(f_Volat(data_xtsInput))
)

# Rename the various columns using the base_name and the technical indicators names
base_name <- tolower(gsub("[[:punct:]]", "", ticker))
col_names <- c("date", "Y", 
                paste0(base_name,"_adjclose"),
                paste0(base_name,"_adjclose_lag1"),
                paste0(base_name,"_adjclose_lag2"),
                paste0(base_name,"_adjclose_lag3"),
                "atr", "adx", "aaron", "bb", "chaikin_vol", "clv", 
                "emv", "macd", "mfi", "sar", "smi", "volat")
names(df_ticker) <- col_names
  
  df_ticker
}

```



# Get the interval of time
```{r}

# Retrieve the cluster which will be used

df_clusters_yearly <- f_cluster_DOW(10)

```



```{r}


window_size = 10

#declare the feature list
featuresList <- vector("list", length(tickers))
names(featuresList) <- tickers

for (i in seq_along(tickers)){
    
    ticker <- tickers[i]
    tmp <- f_constructFeatures(ticker, df_price, window_size)
    featuresList[[i]] = tmp
    print(paste(ticker, " : Done"))

}




```



## Lasso regression

```{r}


f_predictLasso <- function(trainingset, testingset) {
  
  # Formula
  fmla <- Y ~ . - date
  
  # Grid for elastic net
  grid_enet <- expand.grid(alpha = seq(from = 0,
                                      to = 1, 
                                      by = 0.1),
                           lambda = seq(from = 0,
                                       to = 0.05,
                                       length.out = 1001))
  
  # Timeslice train control
  ctr_train <- trainControl(method = "timeslice",
                            initialWindow = 800,
                            horizon = 80,
                            skip = 10,
                            fixedWindow = TRUE,
                            allowParallel = TRUE)
  
  # Convert to data frame
  data <- data.frame(trainingset)
  
  # Train the model
  model_enet_best <- train(form = fmla,
                           data = data,
                           method = "glmnet",
                           tunegrid = grid_enet,
                           trControl = ctr_train, 
                           preProc = c("center", "scale"),
                           metric = "Rsquared")
  
  
  # Predict on the testing set
  predicTest <- predict(model_enet_best, testingset)

   # Extract coefficients from the best model
  coefs <- coef(model_enet_best$finalModel, s = model_enet_best$bestTune$lambda)
  
  # Convert sparse matrix to regular matrix
  matrix_coefs <- as.matrix(coefs)
  
  # Extract non-zero coefficients
  non_zero_coefs <- matrix_coefs[matrix_coefs != 0, , drop=FALSE]
  
  # Convert to data frame
  df_coefs <- as.data.frame(non_zero_coefs)
  
  return(list(model = model_enet_best, predictions = predicTest, coefficients = df_coefs))
}



dates <- featuresList[[tickers[1]]]$date 
    
# Function to get index range based on start and end date
get_date_range <- function(start_date, end_date, offset = 0, dates) {
    idxStart <- dates[which(dates > start_date)][1]
    idxEnd <- dates[which(dates < end_date)]
    idxEnd <- idxEnd[length(idxEnd) - offset]
    return(list(start = idxStart, end = idxEnd))
}

# Get the training and testing date ranges
trainRange <- get_date_range("2007-12-31", "2018-01-01", window_size, dates)
testRange <- get_date_range("2017-12-31", "2023-01-01", 0, dates)



n <- sum(dates %in% testRange$start:testRange$end)
predictionMatrix <- matrix(NA, nrow=n, ncol=length(tickers))
colnames(predictionMatrix) <- tickers


resultsList <- vector("list", length(tickers))
names(resultsList) <- tickers

for (tick in seq_along(tickers)) {
    df <- featuresList[[tick]]
    
    # Subset the data based on the defined time ranges
    trainSet <- df[df$date %in% trainRange$start:trainRange$end, ]
    testSet <- df[df$date %in% testRange$start:testRange$end, ]
    
    results <- f_predictLasso(trainSet, testSet)
    
    # Store results in the main list
    resultsList[[tick]] <- list(
        predictions = as.xts(results$predictions),
        model = results$model,
        mse = mse(actual = testSet$Y, predicted = results$predictions),
        coefficients = results$coefficients
        )
    predictionMatrix[, tick] <- results$predictions

    print(paste(tickers[tick], ", Finished, MSE:", resultsList[[tick]]$mse))
}

resultsList$XOM$predictions








```


